{"version":3,"file":"DosZytHh.js","sources":["../../../../../../node_modules/svelte/src/internal/client/dom/blocks/if.js"],"sourcesContent":["/** @import { Effect, TemplateNode } from '#client' */\n/** @import { Batch } from '../../reactivity/batch.js'; */\nimport { EFFECT_TRANSPARENT } from '#client/constants';\nimport {\n\thydrate_next,\n\thydrate_node,\n\thydrating,\n\tread_hydration_instruction,\n\tremove_nodes,\n\tset_hydrate_node,\n\tset_hydrating\n} from '../hydration.js';\nimport { block, branch, pause_effect, resume_effect } from '../../reactivity/effects.js';\nimport { HYDRATION_START_ELSE, UNINITIALIZED } from '../../../../constants.js';\nimport { create_text, should_defer_append } from '../operations.js';\nimport { current_batch } from '../../reactivity/batch.js';\n\n// TODO reinstate https://github.com/sveltejs/svelte/pull/15250\n\n/**\n * @param {TemplateNode} node\n * @param {(branch: (fn: (anchor: Node) => void, flag?: boolean) => void) => void} fn\n * @param {boolean} [elseif] True if this is an `{:else if ...}` block rather than an `{#if ...}`, as that affects which transitions are considered 'local'\n * @returns {void}\n */\nexport function if_block(node, fn, elseif = false) {\n\tif (hydrating) {\n\t\thydrate_next();\n\t}\n\n\tvar anchor = node;\n\n\t/** @type {Effect | null} */\n\tvar consequent_effect = null;\n\n\t/** @type {Effect | null} */\n\tvar alternate_effect = null;\n\n\t/** @type {typeof UNINITIALIZED | boolean | null} */\n\tvar condition = UNINITIALIZED;\n\n\tvar flags = elseif ? EFFECT_TRANSPARENT : 0;\n\n\tvar has_branch = false;\n\n\tconst set_branch = (/** @type {(anchor: Node) => void} */ fn, flag = true) => {\n\t\thas_branch = true;\n\t\tupdate_branch(flag, fn);\n\t};\n\n\t/** @type {DocumentFragment | null} */\n\tvar offscreen_fragment = null;\n\n\tfunction commit() {\n\t\tif (offscreen_fragment !== null) {\n\t\t\t// remove the anchor\n\t\t\t/** @type {Text} */ (offscreen_fragment.lastChild).remove();\n\n\t\t\tanchor.before(offscreen_fragment);\n\t\t\toffscreen_fragment = null;\n\t\t}\n\n\t\tvar active = condition ? consequent_effect : alternate_effect;\n\t\tvar inactive = condition ? alternate_effect : consequent_effect;\n\n\t\tif (active) {\n\t\t\tresume_effect(active);\n\t\t}\n\n\t\tif (inactive) {\n\t\t\tpause_effect(inactive, () => {\n\t\t\t\tif (condition) {\n\t\t\t\t\talternate_effect = null;\n\t\t\t\t} else {\n\t\t\t\t\tconsequent_effect = null;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tconst update_branch = (\n\t\t/** @type {boolean | null} */ new_condition,\n\t\t/** @type {null | ((anchor: Node) => void)} */ fn\n\t) => {\n\t\tif (condition === (condition = new_condition)) return;\n\n\t\t/** Whether or not there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */\n\t\tlet mismatch = false;\n\n\t\tif (hydrating) {\n\t\t\tconst is_else = read_hydration_instruction(anchor) === HYDRATION_START_ELSE;\n\n\t\t\tif (!!condition === is_else) {\n\t\t\t\t// Hydration mismatch: remove everything inside the anchor and start fresh.\n\t\t\t\t// This could happen with `{#if browser}...{/if}`, for example\n\t\t\t\tanchor = remove_nodes();\n\n\t\t\t\tset_hydrate_node(anchor);\n\t\t\t\tset_hydrating(false);\n\t\t\t\tmismatch = true;\n\t\t\t}\n\t\t}\n\n\t\tvar defer = should_defer_append();\n\t\tvar target = anchor;\n\n\t\tif (defer) {\n\t\t\toffscreen_fragment = document.createDocumentFragment();\n\t\t\toffscreen_fragment.append((target = create_text()));\n\t\t}\n\n\t\tif (condition) {\n\t\t\tconsequent_effect ??= fn && branch(() => fn(target));\n\t\t} else {\n\t\t\talternate_effect ??= fn && branch(() => fn(target));\n\t\t}\n\n\t\tif (defer) {\n\t\t\tvar batch = /** @type {Batch} */ (current_batch);\n\n\t\t\tvar active = condition ? consequent_effect : alternate_effect;\n\t\t\tvar inactive = condition ? alternate_effect : consequent_effect;\n\n\t\t\tif (active) batch.skipped_effects.delete(active);\n\t\t\tif (inactive) batch.skipped_effects.add(inactive);\n\n\t\t\tbatch.add_callback(commit);\n\t\t} else {\n\t\t\tcommit();\n\t\t}\n\n\t\tif (mismatch) {\n\t\t\t// continue in hydration mode\n\t\t\tset_hydrating(true);\n\t\t}\n\t};\n\n\tblock(() => {\n\t\thas_branch = false;\n\t\tfn(set_branch);\n\t\tif (!has_branch) {\n\t\t\tupdate_branch(null, null);\n\t\t}\n\t}, flags);\n\n\tif (hydrating) {\n\t\tanchor = hydrate_node;\n\t}\n}\n"],"names":["if_block","node","fn","elseif","hydrating","hydrate_next","anchor","consequent_effect","alternate_effect","condition","UNINITIALIZED","flags","EFFECT_TRANSPARENT","has_branch","set_branch","flag","update_branch","offscreen_fragment","commit","active","inactive","resume_effect","pause_effect","new_condition","mismatch","is_else","read_hydration_instruction","HYDRATION_START_ELSE","remove_nodes","set_hydrate_node","set_hydrating","defer","should_defer_append","target","create_text","branch","batch","current_batch","block","hydrate_node"],"mappings":"6IAyBO,SAASA,EAASC,EAAMC,EAAIC,EAAS,GAAO,CAC9CC,GACHC,EAAY,EAGb,IAAIC,EAASL,EAGTM,EAAoB,KAGpBC,EAAmB,KAGnBC,EAAYC,EAEZC,EAAQR,EAASS,EAAqB,EAEtCC,EAAa,GAEjB,MAAMC,EAAa,CAAuCZ,EAAIa,EAAO,KAAS,CAC7EF,EAAa,GACbG,EAAcD,EAAMb,CAAE,CACvB,EAGA,IAAIe,EAAqB,KAEzB,SAASC,GAAS,CACbD,IAAuB,OAELA,EAAmB,UAAW,OAAM,EAEzDX,EAAO,OAAOW,CAAkB,EAChCA,EAAqB,MAGtB,IAAIE,EAASV,EAAYF,EAAoBC,EACzCY,EAAWX,EAAYD,EAAmBD,EAE1CY,GACHE,EAAcF,CAAM,EAGjBC,GACHE,EAAaF,EAAU,IAAM,CACxBX,EACHD,EAAmB,KAEnBD,EAAoB,IAEtB,CAAC,CAEH,CAEA,MAAMS,EAAgB,CACSO,EACiBrB,IAC3C,CACJ,GAAIO,KAAeA,EAAYc,GAAgB,OAG/C,IAAIC,EAAW,GAEf,GAAIpB,EAAW,CACd,MAAMqB,EAAUC,EAA2BpB,CAAM,IAAMqB,EAEnD,CAAC,CAAClB,IAAcgB,IAGnBnB,EAASsB,EAAY,EAErBC,EAAiBvB,CAAM,EACvBwB,EAAc,EAAK,EACnBN,EAAW,GAEb,CAEA,IAAIO,EAAQC,EAAmB,EAC3BC,EAAS3B,EAab,GAXIyB,IACHd,EAAqB,SAAS,uBAAsB,EACpDA,EAAmB,OAAQgB,EAASC,GAAa,GAG9CzB,EACHF,MAAsBL,GAAMiC,EAAO,IAAMjC,EAAG+B,CAAM,CAAC,GAEnDzB,MAAqBN,GAAMiC,EAAO,IAAMjC,EAAG+B,CAAM,CAAC,GAG/CF,EAAO,CACV,IAAIK,EAA8BC,EAE9BlB,EAASV,EAAYF,EAAoBC,EACzCY,EAAWX,EAAYD,EAAmBD,EAE1CY,GAAQiB,EAAM,gBAAgB,OAAOjB,CAAM,EAC3CC,GAAUgB,EAAM,gBAAgB,IAAIhB,CAAQ,EAEhDgB,EAAM,aAAalB,CAAM,CAC1B,MACCA,EAAM,EAGHM,GAEHM,EAAc,EAAI,CAEpB,EAEAQ,EAAM,IAAM,CACXzB,EAAa,GACbX,EAAGY,CAAU,EACRD,GACJG,EAAc,KAAM,IAAI,CAE1B,EAAGL,CAAK,EAEJP,IACHE,EAASiC,EAEX","x_google_ignoreList":[0]}